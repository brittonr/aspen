//! Nickel contract code generator.

use std::fmt::Write;

use crate::types::ConfigEnum;
use crate::types::ConfigField;
use crate::types::ConfigStruct;
use crate::types::FieldType;
use crate::types::ParsedConfig;

/// Generate Nickel contract source from parsed configuration.
pub fn generate_nickel_contracts(config: &ParsedConfig) -> String {
    let mut output = String::new();

    // Header
    writeln!(output, "# Auto-generated Nickel contracts").unwrap();
    writeln!(output, "# Generated by aspen-nickel-gen").unwrap();
    writeln!(output, "#").unwrap();
    writeln!(output, "# DO NOT EDIT MANUALLY - regenerate with:").unwrap();
    writeln!(output, "#   aspen-nickel-gen <source-file>").unwrap();
    writeln!(output).unwrap();

    // Generate enum contracts first (they're referenced by structs)
    for e in &config.enums {
        generate_enum_contract(&mut output, e);
        writeln!(output).unwrap();
    }

    // Generate struct contracts
    for s in &config.structs {
        generate_struct_contract(&mut output, s);
        writeln!(output).unwrap();
    }

    // Export all contracts
    writeln!(output, "# Export all contracts").unwrap();
    writeln!(output, "{{").unwrap();

    let mut names: Vec<&str> = config.structs.iter().map(|s| s.name.as_str()).collect();
    names.extend(config.enums.iter().map(|e| e.name.as_str()));

    for (i, name) in names.iter().enumerate() {
        if i < names.len() - 1 {
            writeln!(output, "  {name},").unwrap();
        } else {
            writeln!(output, "  {name},").unwrap();
        }
    }

    writeln!(output, "}}").unwrap();

    output
}

/// Generate a Nickel enum contract.
fn generate_enum_contract(output: &mut String, e: &ConfigEnum) {
    // Doc comment
    if let Some(doc) = &e.doc {
        for line in doc.lines() {
            writeln!(output, "# {line}").unwrap();
        }
    }

    write!(output, "let {} = [| ", e.name).unwrap();

    for (i, variant) in e.variants.iter().enumerate() {
        // Determine the serialized name
        let name = if let Some(ref renamed) = variant.serde_name {
            renamed.clone()
        } else if let Some(ref rename_all) = e.rename_all {
            apply_rename_all(&variant.name, rename_all)
        } else {
            variant.name.clone()
        };

        if i > 0 {
            write!(output, ", ").unwrap();
        }
        write!(output, "'{name}").unwrap();
    }

    writeln!(output, " |] in").unwrap();
}

/// Generate a Nickel struct contract.
fn generate_struct_contract(output: &mut String, s: &ConfigStruct) {
    // Doc comment
    if let Some(doc) = &s.doc {
        for line in doc.lines() {
            writeln!(output, "# {line}").unwrap();
        }
    }

    writeln!(output, "let {} = {{", s.name).unwrap();

    for field in &s.fields {
        generate_field_contract(output, field, "  ");
    }

    writeln!(output, "}} in").unwrap();
}

/// Generate a Nickel field contract.
fn generate_field_contract(output: &mut String, field: &ConfigField, indent: &str) {
    // Use serde name if available, otherwise field name
    let name = field.serde_name.as_ref().unwrap_or(&field.name);

    // Doc comment (inline for cleaner output)
    if let Some(doc) = &field.doc {
        let first_line = doc.lines().next().unwrap_or("");
        writeln!(output, "{indent}# {first_line}").unwrap();
    }

    // Build the contract annotation
    let type_contract = field.field_type.to_nickel();

    // Determine optionality and default
    let has_default = field.has_serde_default || field.default_fn.is_some();
    let is_optional = field.is_optional;

    if has_default {
        // Field with default value
        let default_value = get_default_value(&field.field_type, field.is_optional);
        writeln!(output, "{indent}{name} | {type_contract} | default = {default_value},").unwrap();
    } else if is_optional {
        // Optional field without default
        writeln!(output, "{indent}{name} | {type_contract} | optional,").unwrap();
    } else {
        // Required field
        writeln!(output, "{indent}{name} | {type_contract},").unwrap();
    }
}

/// Get a reasonable default value for a type.
fn get_default_value(field_type: &FieldType, _is_optional: bool) -> String {
    match field_type {
        FieldType::Primitive(p) => {
            if matches!(p, crate::types::PrimitiveType::Bool) {
                "false".to_string()
            } else {
                "0".to_string()
            }
        }
        FieldType::String => "\"\"".to_string(),
        FieldType::PathBuf => "\"\"".to_string(),
        FieldType::SocketAddr => "\"127.0.0.1:0\"".to_string(),
        FieldType::Vec(_) => "[]".to_string(),
        FieldType::Option(inner) => get_default_value(inner, true),
        FieldType::Struct(_) => "{}".to_string(),
        FieldType::Enum(_) => "'default".to_string(), // Placeholder - would need enum info
        FieldType::Unknown(_) => "null".to_string(),
    }
}

/// Apply serde rename_all transformation.
fn apply_rename_all(name: &str, rename_all: &str) -> String {
    match rename_all {
        "lowercase" => name.to_lowercase(),
        "UPPERCASE" => name.to_uppercase(),
        "snake_case" => to_snake_case(name),
        "SCREAMING_SNAKE_CASE" => to_snake_case(name).to_uppercase(),
        "camelCase" => to_camel_case(name, false),
        "PascalCase" => to_camel_case(name, true),
        "kebab-case" => to_snake_case(name).replace('_', "-"),
        "SCREAMING-KEBAB-CASE" => to_snake_case(name).to_uppercase().replace('_', "-"),
        _ => name.to_string(),
    }
}

/// Convert PascalCase to snake_case.
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }
    result
}

/// Convert to camelCase or PascalCase.
fn to_camel_case(s: &str, pascal: bool) -> String {
    let mut result = String::new();
    let mut capitalize_next = pascal;

    for c in s.chars() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_uppercase().next().unwrap());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::EnumVariant;
    use crate::types::PrimitiveType;

    #[test]
    fn test_generate_enum() {
        let e = ConfigEnum {
            name: "StorageBackend".to_string(),
            doc: Some("Storage backend type.".to_string()),
            variants: vec![
                EnumVariant {
                    name: "InMemory".to_string(),
                    doc: None,
                    is_default: false,
                    serde_name: None,
                },
                EnumVariant {
                    name: "Redb".to_string(),
                    doc: None,
                    is_default: true,
                    serde_name: None,
                },
            ],
            rename_all: Some("snake_case".to_string()),
            default_variant: Some("Redb".to_string()),
        };

        let config = ParsedConfig {
            structs: vec![],
            enums: vec![e],
        };

        let output = generate_nickel_contracts(&config);
        assert!(output.contains("'in_memory"));
        assert!(output.contains("'redb"));
    }

    #[test]
    fn test_generate_struct() {
        let s = ConfigStruct {
            name: "MyConfig".to_string(),
            doc: Some("My configuration.".to_string()),
            has_default: true,
            fields: vec![
                ConfigField {
                    name: "name".to_string(),
                    serde_name: None,
                    field_type: FieldType::String,
                    doc: Some("The name.".to_string()),
                    is_optional: false,
                    default_fn: None,
                    has_serde_default: false,
                    skip: false,
                    flatten: false,
                },
                ConfigField {
                    name: "count".to_string(),
                    serde_name: None,
                    field_type: FieldType::Primitive(PrimitiveType::U32),
                    doc: Some("The count.".to_string()),
                    is_optional: false,
                    default_fn: None,
                    has_serde_default: true,
                    skip: false,
                    flatten: false,
                },
            ],
        };

        let config = ParsedConfig {
            structs: vec![s],
            enums: vec![],
        };

        let output = generate_nickel_contracts(&config);
        assert!(output.contains("let MyConfig"));
        assert!(output.contains("name | String"));
        assert!(output.contains("count | Number | default"));
    }

    #[test]
    fn test_snake_case() {
        assert_eq!(to_snake_case("InMemory"), "in_memory");
        assert_eq!(to_snake_case("RedbBackend"), "redb_backend");
        assert_eq!(to_snake_case("HTTPServer"), "h_t_t_p_server");
    }
}
