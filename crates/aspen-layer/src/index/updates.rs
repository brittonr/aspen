//! Index update generation for write operations.

use super::registry::IndexRegistry;
use super::secondary_index::IndexableEntry;

/// Operations to update indexes during writes.
///
/// These are generated by the IndexRegistry and applied within the same
/// transaction as the primary KV write.
#[derive(Debug, Clone, Default)]
pub struct IndexUpdate {
    /// Index entry keys to insert (key -> empty value).
    pub inserts: Vec<Vec<u8>>,
    /// Index entry keys to delete.
    pub deletes: Vec<Vec<u8>>,
}

impl IndexUpdate {
    /// Create an empty update.
    pub fn empty() -> Self {
        Self::default()
    }

    /// Check if the update has any operations.
    pub fn is_empty(&self) -> bool {
        self.inserts.is_empty() && self.deletes.is_empty()
    }

    /// Get total number of operations.
    pub fn operation_count(&self) -> usize {
        self.inserts.len() + self.deletes.len()
    }
}

impl IndexRegistry {
    /// Generate index updates for a Set operation.
    ///
    /// # Arguments
    /// * `primary_key` - The primary key being set
    /// * `old_entry` - Previous entry (if any) - needed to remove old index entries
    /// * `new_entry` - New entry being written
    pub fn updates_for_set(
        &self,
        primary_key: &[u8],
        old_entry: Option<&IndexableEntry>,
        new_entry: &IndexableEntry,
    ) -> IndexUpdate {
        let mut update = IndexUpdate::empty();

        for index in self.indexes().values() {
            // Delete old index entry if it existed and had a value
            if let Some(old) = old_entry
                && let Some(old_value) = index.extract(old)
            {
                update.deletes.push(index.build_key(&old_value, primary_key));
            }

            // Insert new index entry if the new entry has a value
            if let Some(new_value) = index.extract(new_entry) {
                update.inserts.push(index.build_key(&new_value, primary_key));
            }
        }

        update
    }

    /// Generate index updates for a Delete operation.
    ///
    /// # Arguments
    /// * `primary_key` - The primary key being deleted
    /// * `old_entry` - The entry being deleted
    pub fn updates_for_delete(&self, primary_key: &[u8], old_entry: &IndexableEntry) -> IndexUpdate {
        let mut update = IndexUpdate::empty();

        for index in self.indexes().values() {
            if let Some(old_value) = index.extract(old_entry) {
                update.deletes.push(index.build_key(&old_value, primary_key));
            }
        }

        update
    }
}
