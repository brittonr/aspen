# Aspen Plugin Development Guide

Build WASM plugins that extend Aspen with custom request handlers.
Plugins run sandboxed inside hyperlight-wasm and interact with the
cluster through a host-function API: KV store, blob storage,
timers, hook subscriptions, and cryptographic signing.

## Table of Contents

1. [Quickstart](#quickstart)
2. [Architecture](#architecture)
3. [Plugin Lifecycle](#plugin-lifecycle)
4. [Host Functions Reference](#host-functions-reference)
5. [Permissions Model](#permissions-model)
6. [Templates](#templates)
7. [Building and Testing](#building-and-testing)
8. [Signing and Verification](#signing-and-verification)
9. [Deployment](#deployment)
10. [Best Practices](#best-practices)
11. [Troubleshooting](#troubleshooting)

---

## Quickstart

### Prerequisites

- Rust toolchain with `wasm32-unknown-unknown` target
- `cargo-aspen-plugin` (built from `crates/cargo-aspen-plugin/`)

```bash
rustup target add wasm32-unknown-unknown
cargo install --path crates/cargo-aspen-plugin
```

### Create a Plugin (5 Minutes)

```bash
# Scaffold from a template
cargo aspen-plugin init my-plugin --template basic

# Inspect the generated project
cd my-plugin
cargo aspen-plugin check

# Build
cargo aspen-plugin build --release

# Deploy to a running cluster
aspen-cli plugin install \
  target/wasm32-unknown-unknown/release/aspen_my_plugin.wasm \
  --manifest plugin.json
```

---

## Architecture

```
┌─────────────────────────────────────────────────────┐
│                   Aspen Node                         │
│                                                      │
│  ┌──────────────────────────────────────────────┐   │
│  │ Handler Registry (ArcSwap for hot-reload)     │   │
│  │                                                │   │
│  │  ┌─────────────┐  ┌────────────────────────┐  │   │
│  │  │ Native      │  │ WASM Plugin Handlers   │  │   │
│  │  │ Handlers    │  │ (priority 900–999)     │  │   │
│  │  │ (forge, ci) │  │                         │  │   │
│  │  └─────────────┘  └──────────┬─────────────┘  │   │
│  │                               │                │   │
│  └───────────────────────────────┼────────────────┘   │
│                                  │                    │
│  ┌───────────────────────────────▼────────────────┐   │
│  │        hyperlight-wasm Sandbox                  │   │
│  │   ┌───────────────────────────────────┐        │   │
│  │   │ Guest Plugin (your code)           │        │   │
│  │   │ - handle_request()                 │        │   │
│  │   │ - plugin_init()                    │        │   │
│  │   │ - plugin_on_timer()                │        │   │
│  │   │ - plugin_on_hook_event()           │        │   │
│  │   └──────────────┬────────────────────┘        │   │
│  │                  │ Host Functions (FFI)         │   │
│  └──────────────────┼─────────────────────────────┘   │
│                     ▼                                  │
│  ┌──────────────────────────────────────────────┐     │
│  │ KV Store │ Blob Store │ Timers │ Hooks │ Crypto│    │
│  └──────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────┘
```

### Key Concepts

- **Primitive-mode FFI**: Guest and host communicate via simple types
  (strings, byte vectors, integers). No WASI, no Component Model.
- **Request dispatch**: The Handler Registry routes `ClientRpcRequest` variants
  to plugins based on their `handles` list. Lower priority numbers execute first.
- **KV namespace isolation**: Each plugin's KV operations are validated against
  its declared `kv_prefixes`. Operations outside the prefix are rejected.
- **Sandboxed execution**: Plugins run with wall-clock timeouts (default 30s,
  max 300s) and memory limits (default 128 MB).

---

## Plugin Lifecycle

```
Loading → Initializing → Ready → (Degraded) → Stopping → Stopped
                                      ↑
                                   Failed
```

| State        | Description                                           |
|-------------|-------------------------------------------------------|
| Loading     | WASM binary being loaded from blob store               |
| Initializing | `plugin_init()` export called                        |
| Ready       | Accepting requests via `handle_request()`              |
| Degraded    | Operational but health checks reporting issues         |
| Stopping    | `plugin_shutdown()` called during graceful shutdown    |
| Stopped     | All resources released                                 |
| Failed      | Unrecoverable error (init failure, repeated timeouts)  |

### Lifecycle Exports

Your plugin must export these functions (generated by `register_plugin!`):

| Export                    | When Called                      |
|--------------------------|----------------------------------|
| `plugin_info`            | On load — returns plugin metadata |
| `plugin_init`            | Once after load — setup resources |
| `handle_request`         | For each matching RPC request    |
| `plugin_health`          | Periodic health checks           |
| `plugin_on_timer`        | When a scheduled timer fires     |
| `plugin_on_hook_event`   | When a subscribed event fires    |
| `plugin_shutdown`        | On unload                        |

---

## Host Functions Reference

Import these via `aspen_wasm_guest_sdk::host::*`:

### KV Store

| Function | Permission | Description |
|----------|-----------|-------------|
| `kv_get_value(key)` | `kv_read` | Read a value. Returns `Ok(Some(bytes))` / `Ok(None)` / `Err` |
| `kv_put_value(key, value)` | `kv_write` | Write a value |
| `kv_delete_key(key)` | `kv_write` | Delete a key |
| `kv_scan_prefix(prefix, limit)` | `kv_read` | Scan keys by prefix |
| `kv_compare_and_swap(key, expected, new)` | `kv_write` | Atomic compare-and-swap |
| `kv_batch_write(ops)` | `kv_write` | Atomic batch of Set/Delete ops |

### Blob Store

| Function | Permission | Description |
|----------|-----------|-------------|
| `blob_exists(hash)` | `blob_read` | Check if blob exists |
| `blob_get_data(hash)` | `blob_read` | Read blob by BLAKE3 hash |
| `blob_put_data(data)` | `blob_write` | Store blob, returns hash |

### Cluster

| Function | Permission | Description |
|----------|-----------|-------------|
| `is_current_leader()` | `cluster_info` | Am I the Raft leader? |
| `get_leader_id()` | `cluster_info` | Current leader's node ID |
| `get_node_id()` | — | This node's ID |

### Crypto

| Function | Permission | Description |
|----------|-----------|-------------|
| `sign_data(data)` | `signing` | Sign with node's Ed25519 key |
| `verify_signature(pubkey, data, sig)` | `signing` | Verify Ed25519 signature |
| `public_key()` | `signing` | Node's public key (hex) |
| `get_random_bytes(count)` | `randomness` | Cryptographic random bytes |

### Timers

| Function | Permission | Description |
|----------|-----------|-------------|
| `schedule_timer_on_host(config)` | `timers` | Register a timer (1s–24h) |
| `cancel_timer_on_host(name)` | `timers` | Cancel a named timer |

Max 16 timers per plugin. Timers fire the `on_timer(name)` callback.

### Hook Subscriptions

| Function | Permission | Description |
|----------|-----------|-------------|
| `subscribe_hook_events(pattern)` | `hooks` | Subscribe to events |
| `unsubscribe_hook_events(pattern)` | `hooks` | Unsubscribe |

Patterns use NATS-style wildcards:

- `hooks.kv.*` — matches `hooks.kv.write_committed`, `hooks.kv.delete_committed`
- `hooks.cluster.*` — matches `hooks.cluster.leader_elected`
- `hooks.>` — matches all events

Max 16 subscriptions per plugin.

### Logging and Time

| Function | Permission | Description |
|----------|-----------|-------------|
| `log_info_msg(msg)` | — | Log at info level |
| `log_debug_msg(msg)` | — | Log at debug level |
| `log_warn_msg(msg)` | — | Log at warn level |
| `current_time_ms()` | — | Wall-clock time (ms) |
| `hlc_now_ms()` | — | HLC timestamp (ms) |

---

## Permissions Model

Plugins declare required permissions in `plugin.json`:

```json
{
  "permissions": {
    "kv_read": true,
    "kv_write": true,
    "blob_read": false,
    "blob_write": false,
    "cluster_info": false,
    "randomness": false,
    "signing": false,
    "timers": false,
    "hooks": false
  }
}
```

**Default: all denied.** Each host function checks permissions before executing.
Calling a denied function returns an error, not a panic.

### KV Namespace Isolation

Plugins must declare `kv_prefixes` in the manifest:

```json
{
  "kv_prefixes": ["myapp:"]
}
```

All KV operations are validated against these prefixes. If `kv_prefixes` is
empty, the default `__plugin:{name}:` is enforced automatically.

---

## Templates

`cargo aspen-plugin init` supports four templates:

| Template | Description | Permissions |
|----------|-------------|-------------|
| `basic`  | Ping → Pong handler | `kv_read` |
| `kv`     | KV read/write/delete with namespaced keys | `kv_read`, `kv_write` |
| `timer`  | Periodic scheduled task | `kv_read`, `kv_write`, `timers` |
| `hook`   | Event-driven audit logger | `kv_read`, `kv_write`, `hooks` |

### Example: KV Plugin

```bash
cargo aspen-plugin init my-store --template kv --priority 940
```

Generates a plugin that handles `WriteKey`, `ReadKey`, and `DeleteKey` with
automatic key prefixing under `my-store:`.

---

## Building and Testing

### Build

```bash
# Debug build
cargo aspen-plugin build

# Release build (smaller, optimized)
cargo aspen-plugin build --release
```

### Unit Tests

The generated `src/lib.rs` includes a `plugin_info_matches_manifest` test:

```bash
cargo test
```

This ensures your code's `info()` output matches `plugin.json`. Add your own
tests — host functions can't be called in unit tests (they're FFI imports),
so test your logic in pure functions.

### Integration Testing

Deploy to a test cluster and use the CLI:

```bash
# Start a local node
aspen-node --data-dir /tmp/aspen-test &

# Install plugin
aspen-cli plugin install my_plugin.wasm --manifest plugin.json

# Test via CLI
aspen-cli kv set "myprefix:key1" "value1"
aspen-cli kv get "myprefix:key1"
```

---

## Signing and Verification

### Generate a Signing Key

```bash
cargo aspen-plugin keygen
# Output:
# ✓ Generated Ed25519 keypair
#   Secret key: ~/.config/aspen/plugin-signing-key
#   Public key: a1b2c3d4...
```

### Sign a Plugin

```bash
cargo aspen-plugin build --release
cargo aspen-plugin sign --key ~/.config/aspen/plugin-signing-key
# Updates plugin.json with signature field
```

### Verify

```bash
cargo aspen-plugin verify
# Or verify against a specific author key:
cargo aspen-plugin verify --key a1b2c3d4...
```

### Trust Management

The CLI manages trusted author keys:

```bash
# Trust a plugin author
aspen-cli plugin-keys add a1b2c3d4... --name "Alice"

# List trusted authors
aspen-cli plugin-keys list

# Install with verification
aspen-cli plugin install my_plugin.wasm --manifest plugin.json --verify-signature
```

---

## Deployment

### Install

```bash
aspen-cli plugin install <wasm-path> \
  --manifest plugin.json \
  [--name override-name] \
  [--kv-prefixes "prefix1:,prefix2:"] \
  [--priority 950] \
  [--fuel-limit 1000000] \
  [--memory-limit 134217728]
```

### Manage

```bash
aspen-cli plugin list          # List installed plugins
aspen-cli plugin info <name>   # Show plugin details
aspen-cli plugin enable <name> # Enable a disabled plugin
aspen-cli plugin disable <name> # Disable without removing
aspen-cli plugin remove <name> # Uninstall
aspen-cli plugin reload [name] # Hot-reload (requires plugins feature)
```

### Resource Limits

| Resource | Default | Max | Config Field |
|----------|---------|-----|-------------|
| Fuel | 500M | — | `fuel_limit` |
| Memory | 128 MB | — | `memory_limit` |
| Execution time | 30s | 300s | `execution_timeout_secs` |
| Timers | — | 16/plugin | Hardcoded |
| Hook subscriptions | — | 16/plugin | Hardcoded |
| KV pattern length | — | 256 chars | Hardcoded |

---

## Best Practices

### Tiger Style Compliance

1. **Bound everything**: Use the resource limits. Don't assume unbounded memory.
2. **Explicit errors**: Return `ClientRpcResponse::Error` with meaningful codes,
   never panic.
3. **Validate inputs**: Check request fields before processing.
4. **Atomic operations**: Use `kv_batch_write` for multi-key updates.
   Use `kv_compare_and_swap` for concurrent-safe updates.
5. **Idempotent handlers**: The same request should produce the same result.

### KV Patterns

```rust
// Namespaced keys prevent collisions
const PREFIX: &str = "myapp:";

// Timestamped keys for append-only logs
let key = format!("{PREFIX}log:{}", current_time_ms());

// CAS for safe concurrent updates
loop {
    let current = kv_get_value(key)?;
    let new_value = transform(current);
    match kv_compare_and_swap(key, &current, &new_value) {
        Ok(()) => break,
        Err(_) => continue, // Retry on conflict
    }
}

// Batch for atomic multi-key writes
kv_batch_write(&[
    KvBatchOp::Set { key: "a".into(), value: "1".into() },
    KvBatchOp::Set { key: "b".into(), value: "2".into() },
])?;
```

### Error Handling

```rust
fn handle(request: ClientRpcRequest) -> ClientRpcResponse {
    match request {
        ClientRpcRequest::ReadKey { ref key } => {
            match kv_get_value(key) {
                Ok(Some(data)) => ClientRpcResponse::ReadResult(ReadResultResponse {
                    value: Some(data),
                    was_found: true,
                    error: None,
                }),
                Ok(None) => ClientRpcResponse::ReadResult(ReadResultResponse {
                    value: None,
                    was_found: false,
                    error: None,
                }),
                Err(e) => ClientRpcResponse::Error(error_response("READ_FAILED", &e)),
            }
        }
        _ => ClientRpcResponse::Error(error_response("UNHANDLED", "...")),
    }
}
```

---

## Troubleshooting

### Build Errors

**`error: could not find crate aspen_wasm_guest_sdk`**
→ Check your Cargo.toml dependency points to the right git URL or path.

**`error[E0463]: can't find crate for std`**
→ Make sure you're building for `wasm32-unknown-unknown`:

```bash
rustup target add wasm32-unknown-unknown
cargo build --target wasm32-unknown-unknown
```

### Runtime Errors

**Plugin not handling requests**
→ Check `handles` in `plugin.json` matches the `ClientRpcRequest` variant names exactly.

**`PERMISSION_DENIED` errors**
→ The manifest doesn't grant the required permission. Update `plugin.json` and reinstall.

**`KV_PREFIX_DENIED` errors**
→ You're accessing a key outside your declared `kv_prefixes`. Update the prefix list.

**Execution timeout**
→ Plugin took longer than `execution_timeout_secs` (default 30s). Optimize your handler
or increase the timeout in the manifest.

**Plugin not loading after install**
→ Use `aspen-cli plugin reload` to trigger hot-reload. Check node logs for errors.

### Common Gotchas

1. **`value` is `Vec<u8>`, not `String`** — `ClientRpcRequest::WriteKey.value` and
   `ReadResultResponse.value` are byte vectors. Use `String::from_utf8_lossy()` for display.

2. **Host functions can't be called in unit tests** — They're FFI imports that only
   work inside the WASM sandbox. Test pure logic separately.

3. **`register_plugin!` must be called exactly once** — It generates the FFI exports.
   Multiple calls create duplicate symbols.

4. **Postcard discriminant mismatches** — If the CLI and node are compiled with different
   feature flags, enum variant indices may differ. Build with matching features.

---

## Example Plugins

| Plugin | Location | Demonstrates |
|--------|----------|-------------|
| Echo | `examples/plugins/echo-plugin/` | Minimal handler, KV read |
| KV Counter | `examples/plugins/kv-counter/` | CAS-based atomic increment |
| Audit Logger | `examples/plugins/audit-logger/` | Hook subscriptions, event-driven |
| Scheduled Cleanup | `examples/plugins/scheduled-cleanup/` | Timers, batch operations, TTL pattern |
| Secrets Engine | `crates/aspen-secrets-plugin/` | Full KV v2 + Transit encryption |
| Automerge CRDT | `crates/aspen-automerge-plugin/` | CRDT document management |
