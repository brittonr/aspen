{
  description = "MVM-CI Worker MicroVMs";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    microvm = {
      url = "github:astro/microvm.nix";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    mvm-ci-src = {
      url = "path:..";
      flake = false;
    };
  };

  outputs = { self, nixpkgs, microvm, mvm-ci-src }:
    let
      system = "x86_64-linux";
      pkgs = import nixpkgs {
        inherit system;
      };

      # Build mvm-ci worker binary from parent directory
      mvm-ci-worker = pkgs.rustPlatform.buildRustPackage {
        pname = "mvm-ci-worker";
        version = "0.1.0";
        src = mvm-ci-src;

        cargoLock = {
          lockFile = "${mvm-ci-src}/Cargo.lock";
        };

        buildInputs = with pkgs; [
          openssl
          pkg-config
        ];

        nativeBuildInputs = with pkgs; [
          pkg-config
        ];

        # Build only the worker binary
        cargoBuildFlags = [ "--bin" "worker" ];

        meta = {
          description = "MVM-CI Worker Binary";
          homepage = "https://github.com/brittonr/mvm-ci";
        };
      };

    in
    {
      # All packages for the system
      packages.${system} = rec {
        # Worker VM configuration using nixosSystem
        worker-vm = (nixpkgs.lib.nixosSystem {
          inherit system;
          modules = [
            microvm.nixosModules.microvm
            ({ config, pkgs, ... }: {
          # MicroVM settings
          microvm = {
            # Use Firecracker hypervisor
            hypervisor = "firecracker";

            # Memory allocation - default 512MB
            mem = let envMem = builtins.getEnv "MEMORY_MB"; in
              if envMem != "" then pkgs.lib.toInt envMem else 512;

            # vCPU count - default 1
            vcpu = let envVcpu = builtins.getEnv "VCPUS"; in
              if envVcpu != "" then pkgs.lib.toInt envVcpu else 1;

            # Shares (Firecracker doesn't support 9p/virtiofs, use block devices if needed)
            shares = [];

            # Network configuration
            interfaces = [
              {
                type = "tap";
                id = let vmId = builtins.getEnv "VM_ID"; in
                  "vm-${if vmId != "" then vmId else "worker"}";
                mac = "02:00:00:00:00:01";
              }
            ];

            # Enable serial console for debugging
            writableStoreOverlay = "/nix/.rw-store";
          };

          # System configuration
          networking.hostName = let vmId = builtins.getEnv "VM_ID"; in
            "worker-${if vmId != "" then vmId else "vm"}";
          networking.firewall.enable = false;

          # Essential system packages
          environment.systemPackages = with pkgs; [
            curl
            jq
            mvm-ci-worker
          ];

          # Create worker user
          users.users.worker = {
            isNormalUser = true;
            group = "worker";
            home = "/home/worker";
            createHome = true;
          };
          users.groups.worker = {};

          # Worker service that runs on boot with completion signaling
          systemd.services.mvm-ci-worker = {
            description = "MVM-CI Worker";
            wantedBy = [ "multi-user.target" ];
            after = [ "network.target" ];

            environment = {
              CONTROL_PLANE_TICKET = builtins.getEnv "CONTROL_PLANE_TICKET";
              # Job payload passed directly as environment variable
              JOB_PAYLOAD = builtins.getEnv "JOB_PAYLOAD";
              JOB_ID = builtins.getEnv "JOB_ID";
              RUST_LOG = "info";
            };

            # Wrapper script to emit completion markers
            script = ''
              # Emit start marker
              echo "MVM-CI-WORKER: Starting job execution"

              # Run the actual worker and capture exit code
              ${mvm-ci-worker}/bin/worker && EXIT_CODE=0 || EXIT_CODE=$?

              # Emit completion marker based on exit code
              if [ $EXIT_CODE -eq 0 ]; then
                echo "JOB_COMPLETED_SUCCESS"
              else
                echo "JOB_COMPLETED_FAILURE: Exit code $EXIT_CODE"
              fi

              # Exit with same code as worker
              exit $EXIT_CODE
            '';

            serviceConfig = {
              Type = "simple";
              User = "worker";
              Group = "worker";
              WorkingDirectory = "/home/worker";
              Restart = "no"; # Don't restart - VM should exit after job completion
              StandardOutput = "journal";
              StandardError = "journal";
            };
          };

          # Systemd journal configuration
          services.journald.extraConfig = ''
            Storage=volatile
            ForwardToConsole=yes
          '';

          # Enable SSH for debugging (optional)
          services.openssh = {
            enable = false; # Disable by default for security
            settings = {
              PermitRootLogin = "no";
              PasswordAuthentication = false;
            };
          };

          # Minimal system configuration
          boot.kernelParams = [ "console=ttyS0" ];
          system.stateVersion = "24.05";
            })
          ];
        }).config.microvm.declaredRunner;

        # Worker VM with wrapper script for Rust code
        worker-vm-wrapped = pkgs.runCommand "worker-vm-wrapped" {} ''
          mkdir -p $out/bin

          # Copy the original microvm runner
          cp -r ${worker-vm}/* $out/

          # Create the run-vm wrapper script that the Rust code expects
          cat > $out/bin/run-vm <<'EOF'
          #!/bin/sh
          set -e

          # Log file path for the VM output
          LOG_FILE="''${LOG_FILE:-/tmp/vm-$$.log}"

          # Job completion markers for the Rust worker to detect
          echo "Starting VM with log file: $LOG_FILE"

          # Execute the actual microvm and capture output
          exec ${worker-vm}/bin/microvm-run 2>&1 | tee "$LOG_FILE"
          EOF

          chmod +x $out/bin/run-vm
        '';

        # Convenience script to run the VM
        run-vm = pkgs.writeShellScriptBin "run-vm" ''
        set -euo pipefail

        VM_ID=''${VM_ID:-worker-$(date +%s)}
        MEMORY_MB=''${MEMORY_MB:-512}
        VCPUS=''${VCPUS:-1}
        CONTROL_PLANE_TICKET=''${CONTROL_PLANE_TICKET:?CONTROL_PLANE_TICKET must be set}

        echo "Starting MVM-CI Worker VM: $VM_ID"
        echo "Memory: $MEMORY_MB MB"
        echo "vCPUs: $VCPUS"

        # Run the VM
        exec ${self.packages.${system}.worker-vm-wrapped}/bin/run-vm
        '';

        # Default package (use wrapped version)
        default = self.packages.${system}.worker-vm-wrapped;
      };

      # Development shell
      devShells.${system}.default = pkgs.mkShell {
        buildInputs = with pkgs; [
          nix
          firecracker
        ];

        shellHook = ''
          echo "MVM-CI Worker MicroVM Development Environment"
          echo "Available commands:"
          echo "  nix build .#worker-vm    - Build worker VM"
          echo "  nix run .#run-vm         - Run worker VM"
        '';
      };
    };
}
